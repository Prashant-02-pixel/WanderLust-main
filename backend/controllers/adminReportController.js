const User = require("../models/user");
const Listing = require("../models/listing");
const Review = require("../models/review");
const PDFDocument = require("pdfkit");

// Helper function to get date range
const getDateRange = (range) => {
  const endDate = new Date();
  let startDate = new Date();

  switch (range) {
    case "week":
      startDate.setDate(startDate.getDate() - 7);
      break;
    case "month":
      startDate.setMonth(startDate.getMonth() - 1);
      break;
    case "quarter":
      startDate.setMonth(startDate.getMonth() - 3);
      break;
    case "year":
      startDate.setFullYear(startDate.getFullYear() - 1);
      break;
    case "all":
      startDate = new Date(0); // Beginning of time
      break;
    default:
      startDate.setDate(startDate.getDate() - 7); // Default to week
  }

  return { startDate, endDate };
};

// Generate report for users, listings, reviews or all
const generateReport = async (req, res) => {
  try {
    // Check if user is admin
    if (!req.user || !req.user.isAdmin) {
      return res.status(403).json({ message: "Not authorized as admin" });
    }

    const { type = "all", dateRange = "week" } = req.query;
    const { startDate, endDate } = getDateRange(dateRange);

    // Validate report type
    if (!["all", "users", "listings", "reviews"].includes(type)) {
      return res.status(400).json({ message: "Invalid report type" });
    }

    // Create PDF document
    const doc = new PDFDocument();
    const fileName = `wanderlust_${type}_report_${
      new Date().toISOString().split("T")[0]
    }.pdf`;

    // Set response headers for file download
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename=${fileName}`);

    // Pipe PDF directly to response
    doc.pipe(res);

    // Add report title and meta information
    doc
      .font("Helvetica-Bold")
      .fontSize(20)
      .text("WanderLust Admin Report", { align: "center" });
    doc.moveDown();
    doc
      .font("Helvetica")
      .fontSize(12)
      .text(`Report Type: ${type.charAt(0).toUpperCase() + type.slice(1)}`, {
        align: "left",
      })
      .text(
        `Date Range: ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`,
        { align: "left" }
      )
      .text(`Generated on: ${new Date().toLocaleString()}`, { align: "left" })
      .text(`Generated by: ${req.user.username}`, { align: "left" });

    doc.moveDown().moveDown();

    // Fetch data based on report type
    if (type === "all" || type === "users") {
      await generateUsersReport(doc, startDate, endDate);
    }

    if (type === "all" || type === "listings") {
      await generateListingsReport(doc, startDate, endDate);
    }

    if (type === "all" || type === "reviews") {
      await generateReviewsReport(doc, startDate, endDate);
    }

    // Finalize PDF and end response
    doc.end();
  } catch (error) {
    console.error("Error generating report:", error);
    res
      .status(500)
      .json({ message: "Failed to generate report", error: "An error occurred while generating the report" });
  }
};

// Generate users report section
async function generateUsersReport(doc, startDate, endDate) {
  try {
    // Get total users
    const totalUsers = await User.countDocuments();

    // Get new users in date range
    const newUsers = await User.countDocuments({
      createdAt: { $gte: startDate, $lte: endDate },
    });

    // Get users by registration date (grouped by month)
    const usersByMonth = await User.aggregate([
      {
        $match: {
          createdAt: { $gte: startDate, $lte: endDate },
        },
      },
      {
        $group: {
          _id: {
            year: { $year: "$createdAt" },
            month: { $month: "$createdAt" },
          },
          count: { $sum: 1 },
        },
      },
      { $sort: { "_id.year": 1, "_id.month": 1 } },
    ]);

    // Get admin vs regular user counts
    const adminCount = await User.countDocuments({ isAdmin: true });
    const regularUserCount = totalUsers - adminCount;

    // Write section header
    doc
      .font("Helvetica-Bold")
      .fontSize(16)
      .text("User Statistics", { underline: true });
    doc.moveDown();

    // Write user statistics
    doc
      .font("Helvetica")
      .fontSize(12)
      .text(`Total Users: ${totalUsers}`)
      .text(
        `New Users (${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}): ${newUsers}`
      )
      .text(`Admin Users: ${adminCount}`)
      .text(`Regular Users: ${regularUserCount}`);

    doc.moveDown();

    // User distribution by month
    if (usersByMonth.length > 0) {
      doc
        .font("Helvetica-Bold")
        .fontSize(14)
        .text("User Registration by Month");
      doc.moveDown();

      // Create a simple table
      const monthNames = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ];

      usersByMonth.forEach((item) => {
        const month = monthNames[item._id.month - 1];
        const year = item._id.year;
        doc
          .font("Helvetica")
          .fontSize(12)
          .text(`${month} ${year}: ${item.count} users`, { continued: false });
      });
    } else {
      doc
        .font("Helvetica")
        .fontSize(12)
        .text("No new users registered in the selected date range.");
    }

    // Add a page break
    doc.addPage();
  } catch (error) {
    console.error("Error generating users report:", error);
    doc
      .font("Helvetica")
      .fontSize(12)
      .text("Error generating users report section.", { color: "red" });
  }
}

// Generate listings report section
async function generateListingsReport(doc, startDate, endDate) {
  try {
    // Get total listings
    const totalListings = await Listing.countDocuments();

    // Get new listings in date range
    const newListings = await Listing.countDocuments({
      createdAt: { $gte: startDate, $lte: endDate },
    });

    // Get listings by status
    const [activeListings, pendingListings, rejectedListings] = await Promise.all([
      Listing.countDocuments({ status: "approved" }),
      Listing.countDocuments({ status: "pending" }),
      Listing.countDocuments({ status: "rejected" })
    ]);

    // Get featured listings count
    const featuredListings = await Listing.countDocuments({ featured: true });

    // Get listings by category
    const listingsByCategory = await Listing.aggregate([
      {
        $group: {
          _id: "$category",
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
    ]);

    // Get average price
    const priceStats = await Listing.aggregate([
      {
        $group: {
          _id: null,
          avgPrice: { $avg: "$price" },
          minPrice: { $min: "$price" },
          maxPrice: { $max: "$price" },
        },
      },
    ]);

    // Write section header
    doc
      .font("Helvetica-Bold")
      .fontSize(16)
      .text("Listing Statistics", { underline: true });
    doc.moveDown();

    // Write listing statistics
    doc
      .font("Helvetica")
      .fontSize(12)
      .text(`Total Listings: ${totalListings}`)
      .text(
        `New Listings (${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}): ${newListings}`
      )
      .text(`Active Listings: ${activeListings}`)
      .text(`Pending Listings: ${pendingListings}`)
      .text(`Rejected Listings: ${rejectedListings}`)
      .text(`Featured Listings: ${featuredListings}`);

    if (priceStats.length > 0) {
      doc
        .moveDown()
        .text(`Average Price: $${priceStats[0].avgPrice.toFixed(2)}`)
        .text(
          `Price Range: $${priceStats[0].minPrice.toFixed(
            2
          )} - $${priceStats[0].maxPrice.toFixed(2)}`
        );
    }

    doc.moveDown();

    // Listings by category
    if (listingsByCategory.length > 0) {
      doc.font("Helvetica-Bold").fontSize(14).text("Listings by Category");
      doc.moveDown();

      listingsByCategory.forEach((item) => {
        const category = item._id || "Uncategorized";
        doc
          .font("Helvetica")
          .fontSize(12)
          .text(`${category}: ${item.count} listings`);
      });
    } else {
      doc
        .font("Helvetica")
        .fontSize(12)
        .text("No category data available.");
    }

    // Add a page break
    doc.addPage();
  } catch (error) {
    console.error("Error generating listings report:", error);
    doc
      .font("Helvetica")
      .fontSize(12)
      .text("Error generating listings report section.", { color: "red" });
  }
}

// Generate reviews report section
async function generateReviewsReport(doc, startDate, endDate) {
  try {
    // Get total reviews
    const totalReviews = await Review.countDocuments();

    // Get new reviews in date range
    const newReviews = await Review.countDocuments({
      createdAt: { $gte: startDate, $lte: endDate },
    });

    // Get approved vs pending reviews
    const approvedReviews = await Review.countDocuments({ approved: true });
    const pendingReviews = totalReviews - approvedReviews;

    // Get average rating
    const ratingStats = await Review.aggregate([
      {
        $group: {
          _id: null,
          avgRating: { $avg: "$rating" },
          totalReviews: { $sum: 1 },
        },
      },
    ]);

    // Get rating distribution
    const ratingDistribution = await Review.aggregate([
      {
        $group: {
          _id: "$rating",
          count: { $sum: 1 },
        },
      },
      { $sort: { _id: 1 } },
    ]);

    // Write section header
    doc
      .font("Helvetica-Bold")
      .fontSize(16)
      .text("Review Statistics", { underline: true });
    doc.moveDown();

    // Write review statistics
    doc
      .font("Helvetica")
      .fontSize(12)
      .text(`Total Reviews: ${totalReviews}`)
      .text(
        `New Reviews (${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}): ${newReviews}`
      )
      .text(`Approved Reviews: ${approvedReviews}`)
      .text(`Pending Reviews: ${pendingReviews}`);

    if (ratingStats.length > 0) {
      doc
        .moveDown()
        .text(`Average Rating: ${ratingStats[0].avgRating.toFixed(2)} / 5`);
    }

    doc.moveDown();

    // Rating distribution
    if (ratingDistribution.length > 0) {
      doc.font("Helvetica-Bold").fontSize(14).text("Rating Distribution");
      doc.moveDown();

      // Create a simple rating distribution chart
      for (let i = 5; i >= 1; i--) {
        const found = ratingDistribution.find((item) => item._id === i);
        const count = found ? found.count : 0;
        const percentage =
          totalReviews > 0 ? ((count / totalReviews) * 100).toFixed(1) : 0;

        doc
          .font("Helvetica")
          .fontSize(12)
          .text(`${i} Stars: ${count} reviews (${percentage}%)`, {
            continued: false,
          });
      }
    } else {
      doc
        .font("Helvetica")
        .fontSize(12)
        .text("No rating distribution data available.");
    }
  } catch (error) {
    console.error("Error generating reviews report:", error);
    doc
      .font("Helvetica")
      .fontSize(12)
      .text("Error generating reviews report section.", { color: "red" });
  }
}

module.exports = {
  generateReport,
  getDateRange
};